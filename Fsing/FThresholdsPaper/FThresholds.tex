\documentclass{amsart}
\usepackage{calc,amssymb,amsthm,amsmath,amsfonts,setspace}
\RequirePackage[dvipsnames,usenames]{xcolor}

\usepackage{fancyvrb}
\usepackage{hyperref}
\hypersetup{
bookmarks,
bookmarksdepth=3,
bookmarksopen,
bookmarksnumbered,
pdfstartview=FitH,
colorlinks,backref,hyperindex,
linkcolor=Sepia,
anchorcolor=BurntOrange,
citecolor=MidnightBlue,
citecolor=OliveGreen,
filecolor=BlueViolet,
menucolor=Yellow,
urlcolor=OliveGreen
}
\usepackage{xspace}
\interfootnotelinepenalty=100000

\usepackage{mabliautoref}
\usepackage{colonequals}
\frenchspacing
\input{kmacros3.sty}

\usepackage{verbatim}
\usepackage{enumerate}
\usepackage[normalem]{ulem}
%\usepackage{marginnote}
\newcommand{\fram}{\mathfrak{m}}
\DefineVerbatimEnvironment%
{MyVerbatim}{Verbatim}
{formatcom=\color{Violet}}

\usepackage{fancyhdr}


\pagestyle{fancy}
\fancyhead[RO, LE]{\thepage}
\fancyhead[C]{The \emph{FrobeniusThresholds} package for \emph{Macaulay2}}
\fancyfoot{}
\renewcommand{\headrulewidth}{0pt}


\makeatletter
\def\@settitle{\begin{center}%
  \baselineskip14\p@\relax
    \bfseries
    \normalfont\LARGE%<- NEW
\@title
  \end{center}%
}
\makeatother

\newcommand{\ft}{\operatorname{c}}
\newcommand{\idealm}{\mathfrak{m}}




\begin{document}
\title[]{The \emph{FrobeniusThresholds} package for \emph{Macaulay2}}

\author[]{Daniel J.\ Hern\'andez}
\address{Department of Mathematics, University of Kansas, Lawrence, KS~66045, USA}
\email{hernandez@ku.edu}
\thanks{D.~J.~Hern\'andez was partially supported by NSF DMS \#1600702.}

%\author[]{Sara Malec}
%\address{Department of Mathematics, Hood College, Frederick, MD 21701}
%\email{malec@hood.edu}

%\author[]{Marcus Robinson}
%\address{Department of Mathematics, University of Utah, Salt Lake City, UT~84112, USA}
%\email{robinson@math.utah.edu}

\author[]{Karl Schwede}
\address{Department of Mathematics, University of Utah, Salt Lake City, UT~84112, USA}
\thanks{K.~Schwede was supported by NSF CAREER Grant DMS \#1252860/1501102, NSF FRG Grant DMS \#1265261/1501115, NSF grant \#1801849 and a Sloan Fellowship.}
\email{schwede@math.utah.edu}

\author[]{Pedro Teixeira}
\address{Department of Mathematics, Knox College, Galesburg, IL~61401, USA}
\email{pteixeir@knox.edu}

\author[]{Emily E.\ Witt}
\address{Department of Mathematics, University of Kansas, Lawrence, KS~66045, USA}
\email{witt@ku.edu}
\thanks{E.~E.~Witt was partially supported by NSF DMS \#1623035.}
\date{\today}

\begin{abstract}
   This article describes the \emph{Macaulay2} package \emph{FrobeniusThresholds}.
   This package is designed to estimate and calculate $F$-pure thresholds, more general $F$-thresholds, and related numerical invariants arising in the study of singularities in prime characteristic commutative algebra.
\end{abstract}

\subjclass[2010]{13A35}

\keywords{Macaulay2, Frobenius, $F$-singularity, $F$-pure threshold, $F$-threshold}

\maketitle

\section{Introduction}

This paper describes the \emph{Macaulay2} \cite{M2} package \emph{FrobeniusThresholds} \cite{FThresholdsPackage}, which provides tools for computing certain fundamental invariants arising in positive characteristic commutative algebra.  More precisely, this package concerns the effective computation of \emph{$F$-pure thresholds}, \emph{$F$-thresholds}, and \emph{$F$-jumping exponents}.

Recall that a ring of prime characteristic $p>0$ is said to be \emph{$F$-pure} if the Frobenius map|that is, the ring endomorphism sending an element to its $p$-th power|is a pure morphism;  under natural geometric hypotheses, this is equivalent to the condition that the Frobenius morphism splits as a map of rings.

The concept of $F$-purity has proven to be important in commutative algebra, and has a rich history.  Indeed, it first appeared in the work \cite{HochsterRobertsFrobeniusLocalCohomology}  of Hochster and Roberts to study local cohomology \cite{HochsterRobertsFrobeniusLocalCohomology}, was compared with rational singularities in  \cite{FedderFPureRat}, and was used to study global properties of Schubert varieties in \cite{MehtaRamanathanFrobeniusSplittingAndCohomologyVanishing}.

After the advent of tight closure \cite{HochsterHunekeTC1}, the usage of Frobenius to quantify singularity|that is, deviation from regularity|proliferated, and based on a connection discovered between $F$-pure and \emph{log canonical} singularities \cite{HaraWatanabeFRegFPure}, the concept of $F$-purity was generalized to the context of \emph{pairs}.
% $(R, f^t)$, where $f$ is an element of $R$, and $t$ is a nonnegative real number considered a formal exponent.

Along these lines, the \emph{$F$-pure threshold} %associated to an element of $R$
was defined in analogy with the \emph{log canonical threshold} \cite{TakagiWatanabeFPureThresh}, and
%The $F$-pure threshold of the pair $(R, f)$ is the supremum over all $t$ for which $(R, f^t)$ is $F$-pure.
\emph{$F$-threholds} were then introduced as a family of invariants that naturally extend the notion of an $F$-pure threshold \cite{MustataTakagiWatanabeFThresholdsAndBernsteinSato}.

Though the $F$-pure threshold is defined in analogy with the log canonical threshold, their connection extends beyond mere analogy. For example, suppose $h$ is a polynomial with integer coefficients, and that $h_p$ is the polynomial obtained by reducing the coefficients of $h$ modulo a prime $p$.  Then, the $F$-pure thresholds of the reductions $h_p$ limit to the log canonical threshold of $h$ as $p$ tends to infinity \cite{HaraYoshidaGeneralizationOfTightClosure}.    A related result is that of Z.~Zhu, who proved in  \cite[Corollary 4.2]{ZhuLogCanoincalThresholdsInPositiveChar} that the log canical threshold of $h$ at least the $F$-pure threshold of any reduction $h_p$.

This latter result is interesting from a computational perspective, in that it provides lower bounds for log canonical thresholds.  Furthermore, though there is a general purpose implementation of an algorithm for computing log canonical thresholds in the \emph{Dmodules} package by A.~Leykin and H.~Tsai \cite{DmodulesSource}, it happens that the function for computing $F$-pure thresholds contained in the \emph{FrobeniusThresholds} package is typically much faster, especially so in lower characteristic.  Note that the  \emph{MultiplierIdeals}  package  by Z.~Teitler, B.~Snapp and C.~Raicu also computes log canonical thresholds in many special cases, including monomial ideals, hyperplane arrangements, generic determinantal ideals, and certain binomial ideals \cite{MultiplierIdealsPackage, MultiplierIdealsArticle}.

In summary,  the $F$-pure threshold is an interesting numerical invariant, and is related to many other such measures of singularity across all characteristics.  Unfortunately, it is typically difficult to calculate, even in many concrete cases.  Nevertheless, $F$-pure thresholds have been the focus of intense study over the past 15 years, and the package \emph{FrobeniusThresholds} is centered on calculating and estimating the $F$-pure threshold and other $F$-thresholds, with the function {\tt fpt} at its core.

\subsection*{Some background and notation}
It is important to note that much of the functionality implemented in the \emph{FrobeniusThresholds} is not restricted to regular ambient rings; see Section \ref{sec.IsFPT} for a prominent example of this.

However, for the sake of concreteness, we will mostly work in a polynomial ring over a finite field of  characteristic $p>0$.  In fact,  we will work in this context exclusively in this introduction.  Thus, unless otherwise stated, all ring elements and ideals under consideration are regarded as elements in such a ring.  The ideal of this ring generated by its variables is denoted $\idealm$.

Let us outline a common way in which natural numerical invariants in prime characteristic commutative algebra are constructed:  For every natural number $e$, associate to some fixed set of data|often, a collection of polynomials and ideals|an integer describing something of relevance that depends on $e$ (e.g., the dimension of some interesting vector space constructed in terms of your initial data).   Finally, normalize this integer by dividing by some power of $p^e$, and then take the limit as the integer $e$ tends to infinity.  The resulting limit, should it exist, should then encode some interesting information about your initial set of data.

Consider a nonzero polynomial $f$ and a natural number $e$.  If $f$ does not vanish at the origin, then set set $\nu_f^{\idealm}(p^e) := \infty$.  Otherwise, $f \in \idealm$, and we instead define
\[ \nu_f^{\idealm}(p^e) := \max \{ n>0 : f^n \notin \idealm^{[p^e]} \} \]
where $\idealm^{[p^e]}$ denotes the $p^e$-th Frobenius power of $\idealm$, that is, the ideal generated by the $p^e$-th powers of the elements of $\idealm$.    It is not very hard to see that this number is exactly the largest power of $f$ that is part of a free basis for the localization of the ambient polynomial ring at the origin over its subring of $p^e$-th powers.  As noted earlier, this number also has a natural interpretation in terms of $F$-purity of pairs.

Following our outline, we define
\[ \ft^{\idealm}(f) := \lim_{e \to \infty} \frac{ \nu_f^{\idealm}(p^e)}{p^e} \]

Inspired by its connections with the $F$-purity of pairs,  this limit is called the \emph{$F$-pure threshold} of $f$ at the origin.  This limit exists, and is finite when $f \in \idealm$.  In the latter case, the limit is also rational, but this is far from obvious  \cite{BlickleMustataSmithDiscretenessAndRationalityOfFThresholds}.

The $F$-pure threshold is closely related to many other fundamental concepts in prime characteristic commutative algebra.   For instance,
\[ \ft^{\idealm}(f) = \inf \{ t>0 : \tau(f^t)  \subseteq \idealm \} = \sup \{ t>0 : \sigma( f^t) \neq 0 \} \]
where $\tau(f^t)$ and $\sigma(f^t)$ are the \emph{test ideal} and \emph{$F$-signature}, respectively, associated to $f$ and the formal nonnegative real exponent $t$.  The former is an ideal in the ambient ring of $f$, and the latter is a real number;  both depend on the parameter $t$ and prime $p$ in subtle ways \cite{BlickleMustataSmithDiscretenessAndRationalityOfFThresholds, BlickleSchwedeTuckerFSigPairs1}.
Though we will not elaborate much on these topics,  we stress that the \emph{Macaulay2} package \emph{TestIdeals} provides functionality for the effective computation of test ideals in many cases \cite{TestIdealsPackage, TestIdealsPaper}.

In the literature, the $F$-pure threshold $\ft^{\idealm}(f)$ is often denoted $\fpt(f)$, for obvious reasons.  However, in this note, we adopt the former notation to avoid any possible confusion with the \emph{Macaulay2} function {\tt fpt} described in Section \ref{sec.FPT}.  Indeed, the command {\tt fpt(f)} need not always output the number $\ft^{\idealm}(f) = \fpt(f)$, though in the case that it cannot, it will provide a reasonably good estimate of this number.

It turns out that the sequence $\{ \nu_f^{\idealm}(p^e) \}_{e=1}^{\infty}$ itself, and not just its limit, also encodes interesting information about $f$.  For example, it is closely related to the so-called \emph{Bernstein-Sato polynomial} \cite{MustataTakagiWatanabeFThresholdsAndBernsteinSato}.  Thus, it is natural to ask whether one can recover the sequence $\{ \nu_f^{\idealm}(p^e) \}_{e=1}^{\infty}$ from the limit $\ft^{\idealm}(f)$.  Fortunately, the answer to this question is yes \cite{MustataTakagiWatanabeFThresholdsAndBernsteinSato, HernandezFPurityOfHypersurfaces}. More precisely,
\begin{equation*}
\nu_f^{\idealm}(p^e) = \lceil p^e \cdot \ft^{\idealm}(f) \rceil - 1.
\end{equation*}

We conclude this subsection by briefly reviewing some natural generalizations.  Suppose that $I$ and $J$ are ideals.  If $I$ is contained in the radical of $J$, then we set
%
\[ \nu_I^J(p^e) = \max \{ n : I^n \notin J^{[p^e]} \}. \]
Otherwise, we set $\nu_I^J(p^e) = \infty$.
This clearly generalizes the quantity $\nu_f^{\idealm}(p^e)$ considered earlier, and we call
\[ \ft^J(I) := \lim_{e \to \infty} \frac{ \nu_f^{\idealm}(p^e)}{p^e} \]
the \emph{$F$-threshold of $I$ with respect to $J$}.  These numbers are also rational, when they are finite.
The value $\ft^{\idealm}(I)$ is called the \emph{$F$-pure threshold of $I$}, and if $I = (f)$ is principal,  $\ft^{J}(f) := \ft^J(I)$ is called the \emph{$F$-threshold of $f$ with respect to $J$}.
Like $F$-pure thresholds, $F$-thresholds can also be defined in terms of its test ideals.

Finally, we point out that the  \emph{FrobeniusThresholds} package builds heavily upon the \emph{TestIdeals} package for \emph{Macaulay2} \cite{TestIdealsPackage, TestIdealsPaper,M2}, which provides a broad range of functionality for effective computation in prime characteristic commutative algebra.  In fact, both this package and \emph{TestIdeals} are derived from an older package \emph{PosChar}.

\subsection*{Organization}

There are three main sections in this paper, which describe and illustrate the main functionality implemented in the package \emph{FrobeniusThresholds}.
\begin{itemize}
\item[$\circ$] \autoref{sec.Nu} describes the fundamental function {\tt nu}.  As its name suggests, this function is concerned with computing the integers $\nu_I^J(p^e)$ described above.
\item[$\circ$] \autoref{sec.IsFPT} explains the functionality for determining whether a given number is the $F$-pure threshold, or more generally, an \emph{$F$-jumping exponent}.
\item[$\circ$] \autoref{sec.FPT} describes the features of the central function of the package, {\tt fpt}.
\item[$\circ$]  \autoref{sec.FutureDirections} describes our plans for future improvements to this package.
\end{itemize}
%{\color{red} Move this later}

\subsection*{Acknowledgements.}  First and foremost, the authors enthusiastically thank all authors and contributors to the
\emph{FrobeniusThresholds} package.  {\color{red} (CHECK THESE NAMES)}
Our package coauthors are Juliette Bruce and Daniel Smolkin.  Erin Bela, Zhibek Kadyrsizova, Moty Katzman, Sara Malec, and Marcus Robinson also contributed valuable code to the package.

Thanks go to the organizers of the \emph{Macaulay2} workshops where much of the functionality described herein was developed, hosted by Wake Forest University in 2012, the University of California, Berkeley in 2014 and 2017, Boise State University in 2015, and the University of Utah in 2016.

Finally, we are grateful to the University of Utah for hosting a collaborative development visit in 2018, and to the Institute of Mathematics and its Applications for its generous support for our 2019 Coding Sprint.
The current version of the package was finalized during these events.

\section{The {\tt nu} function}
\label{sec.Nu}


We first consider the {\tt nu} function, a fundamental component of the package \emph{FrobeniusThresholds}.   As in the introduction, in this section we work in a polynomial ring over a finite field of characteristic $p>0$.  As in the introduction, $\idealm$ will denote the ideal of this ring generated by the variables.

Fix a natural number $e$.  If $f$ is a nonzero polynomial contained in the radical of an ideal $J$, then the command {\tt nu(e,f,J)} outputs the integer $\nu_f^J(p^e)$ defined in the introduction, and
%, the maximal integer exponent such that $f^n$ is not contained in $J^{[p^e]}$.
more generally, if a nonzero ideal $I$ is contained in the radical of $J$, then {\tt nu(e,I,J)} outputs $\nu_I^J(p^e)$. Consider the following example.  %, the maximal integer exponent $n$ such that $I^n$ is not contained in $J^{[p^e]}$.

{\small
\setstretch{.67}
\begin{MyVerbatim}

i1 : R = ZZ/11[x,y];

i2 : I = ideal(x^2 + y^3, x*y);

o2 : Ideal of R

i3 : J = ideal(x^2, y^3);

o3 : Ideal of R

i4 : nu(1, I, J)

o4 = 24

i5 : f = x*y*(x^2 + y^2);

i6 : nu(1, f, J)

o6 = 10
\end{MyVerbatim}
}
\medspace

% R = ZZ/11[x,y];
% I = ideal(x^2 + y^3, x*y);
% J = ideal(x^2, y^3);
% nu(1, I, J)
% f = x*y*(x^2 + y^2);
% nu(1, f, J)

We highlight some degenerate cases:  If $f$ is the zero polynomial, then {\tt nu(e,f,J)} outputs {\tt 0}, and if $f$ is \emph{not} contained in the radical of $J$, then the output is instead {\tt infinity}.  These degenerate cases extend analogously to the command {\tt nu(e,I,J)}.

{\small
\setstretch{.67}
\begin{MyVerbatim}

i7 : nu(1, 0_R, J)

o7 = 0

i8 : nu(1, 1_R, J)

o8 = infinity

o8 : InfiniteNumber
\end{MyVerbatim}
}
\medspace

%nu(1, 0_R, J)
%nu(1, 1_R, J)

If the third argument is omitted from the function {\tt nu}, it is assumed to be the maximal ideal $\idealm$.

{\small
\setstretch{.67}
\begin{MyVerbatim}

i9 : R = ZZ/17[x,y,z];

i10 : f = x^3 + y^4 + z^5;

i11 : m = ideal(x, y, z);

o11 : Ideal of R

i12 : nu(2, f) == nu(2, f, m)

o12 = true
\end{MyVerbatim}
}
\medspace

%R = ZZ/17[x,y,z];
%f = x^3 + y^4 + z^5;
%M = ideal(x, y, z);
%nu(2, f) == nu(2, f, M)

It is well known that if $q=p^e$ for some nonnegative integer $e$, then \[ \nu_I^J(qp) = \nu_I^J(q)\cdot p + L\]  where the error term $L$ is nonnegative, and can be explicitly bounded from above in terms of $p$ and the number of generators of $I$ and $J$.  For instance, the error term $L$ is at most $p-1$ when $I$ is principal and $J$ is arbitrary.

This implies that when searching for the maximal exponent defining {\tt nu(e,I,J)} for positive $e$, it is safe to start at $p$ times the output of {\tt nu(e-1,I,J)}, and one needn't search too far past this number.  This also suggests that the most efficient way to compute {\tt nu(e,I,J)} is to compute, successively, {\tt nu(s,I,J)}, for each $s = 0,\ldots,e$.  This is indeed how the computation is done in most cases.

As pointed out in the introduction, if $f \in \mathfrak{m}$, the values $\nu^{\mathfrak{m}}_f(p^e)$ can be recovered from the $F$-pure threshold of $f$.
This fact is used to speed up computations for certain polynomials whose $F$-pure thresholds can be computed quickly via specialized algorithms, namely diagonal polynomials, binomials, and forms in two variables (see Section \ref{sec.FPT}).  This feature can be disabled by setting the option {\tt UseSpecialAlgorithms} (default value {\tt true}) to {\tt false}.  Consider the following example, where $f$ is a diagonal polynomial.

{\small
\setstretch{.67}
\begin{MyVerbatim}

i1 : R = ZZ/17[x,y,z];

i2 : f = x^3 + y^4 + z^5; -- a diagonal polynomial

i3 : time nu(3, f)
     -- used 0.00552312 seconds

o3 = 3756

o4 : QQ

i4 : time nu(3, f, UseSpecialAlgorithms => false)
     -- used 0.155826 seconds

o4 = 3756
\end{MyVerbatim}
}
\medspace

% R = ZZ/17[x,y,z];
% f = x^3 + y^4 + z^5; -- a diagonal polynomial
% time nu(3, f)
% time nu(3, f, UseSpecialAlgorithms => false)


\subsection*{Options for the {\tt nu} function}

We now describe the options available for the function {\tt nu}.  We focus primarily on the case where the second input is an ideal $I$, since the options work analogously when the second input is instead a polynomial $f$.

In general, the function {\tt nu} works by searching through the list of integers $n$, and checking containments of the $n$-th power of $I$ in a specified Frobenius power of $J$.
The user can specify how this search is approached through the  option {\tt Search}.  Namely, a binary search is used when {\tt Search} is set to {\tt Binary} (and this is the option's default value), and a linear search is run when it is set to {\tt Linear}.

{\small
\setstretch{.67}
\begin{MyVerbatim}

i1 : R = ZZ/5[x,y,z];

i2 : f = x^2*y^4 + y^2*z^7 + z^2*x^8;

i3 : time nu(5, f) -- uses binary search (default)
     -- used 0.313778 seconds

o3 = 1124

i4 : time nu(5, f, Search => Linear)
     -- used 0.441903 seconds

o4 = 1124

i5 : m = ideal(x, y, z);

o5 : Ideal of R

i6 : time nu(2, m, m^2) -- uses binary search (default)
     -- used 1.58258 seconds

o6 = 97

i7 : time nu(2, m, m^2, Search => Linear) -- but linear seach gets luckier
     -- used 0.531175 seconds

o7 = 97
\end{MyVerbatim}
}
\medspace

%R = ZZ/5[x,y,z];
%f = x^2*y^4 + y^2*z^7 + z^2*x^8;
% time nu(5, f) -- uses binary search (default)
% time nu(5, f, Search => Linear)
% M = ideal(x, y, z);
% time nu(2, M, M^2) -- uses binary search (default)
% time nu(2, M, M^2, Search => Linear) -- but linear seach gets luckier


If the option {\tt ReturnList} is changed from its default value of {\tt false} to {\tt true}, rather than simply outputting $\nu_I^J(p^e)$, {\tt nu} outputs a list of the values $\nu_I^J(p^s)$, for $s=0,\ldots,e$.
Alternatively, the same information can be found by setting the option {\tt Verbose} to {\tt true} (its default value is {\tt false}), to request that each of these values $\nu_I^J(p^s)$ is printed as they are iteratively computed.  This can also serve a way to monitor the progress of the computation.


{\small
\setstretch{.67}
\begin{MyVerbatim}

i8 : nu(5, f, ReturnList => true)

o8 = {0, 1, 8, 44, 224, 1124}

o8 : List

i9 : nu(5, f, Verbose => true)

     nu(1) = 0
     nu(p^1) = 1
     nu(p^2) = 8
     nu(p^3) = 44
     nu(p^4) = 224
     nu(p^5) = 1124
\end{MyVerbatim}
}
\medspace

%nu(5, f, ReturnList => true)
%nu(5, f, Verbose => true)

As described in the introduction, the integer $\nu_I^J(p^e)$ is defined in terms of the containment conditions on powers of ideals.
For positive integers $n$ and $e$, and an ideal $I$ contained in the radical of another ideal $J$, we have that
\begin{equation*}
  I^n \subseteq J^{[p^e]} \Longleftrightarrow (I^n)^{[1/p^e]} \subseteq J
\end{equation*}
where $(I^n)^{[1/p^e]}$ denotes the $p^e$-th \emph{Frobenius root} of $I^n$, as defined in \cite{BlickleMustataSmithDiscretenessAndRationalityOfFThresholds}.
The option {\tt ContainmentTest} for {\tt nu} allows the user to choose which of the two types of containment statements appearing above to use toward the calculation of $\nu_I^J(p^e)$.

If {\tt ContainmentTest} is set to {\tt StandardPower}, then {\tt nu(e,I,J)} is computed by testing the left-hand containment above, and when it is set to {\tt FrobeniusRoot}, the right-hand containment is checked.
For efficiency reasons, the default value for {\tt ContainmentTest} is set to  {\tt FrobeniusRoot} if the second argument passed to {\tt nu} is a polynomial, and is set to {\tt StandardPower} if it is an ideal.

{\small
\setstretch{.67}
\begin{MyVerbatim}

i1 : R = ZZ/11[x,y,z];

i2 : f = x^3 + y^3 + z^3 + x*y*z;

i3 : time nu(3, f) -- ContainmentTest is set to FrobeniusRoot, by default
     -- used 0.116697 seconds

o3 = 1209

i4 : time nu(3, f, ContainmentTest => StandardPower)
     -- used 9.65013 seconds

o4 = 1209
\end{MyVerbatim}
}
\medspace

% R = ZZ/11[x,y,z];
% f = x^3 + y^3 + z^3 + x*y*z;
% time nu(3, f) -- ContainmentTest is set to FrobeniusRoot, by default
% time nu(3, f, ContainmentTest => StandardPower)

The option {\tt ContainmentTest} has a third possible value, {\tt FrobeniusPower}, which may produce a different result than the other two values.
Given an ideal $I$, the first, third, and fourth authors introduced the notion of a (generalized) Frobenius power $I^{[n]}$ of $I$, when $n$ is an arbitrary positive integer, not necessarily of the form $n = p^e$ \cite{hernandez+etal.frobenius_powers}.
When {\tt ContainmentTest} is set to {\tt FrobeniusPower}, rather than  computing $\nu_I^J(p^e)$, the function {\tt nu} computes the
maximal integer $n$ for which $I^{[n]}$ is not contained in $J^{[p^e]}$.  This number is denoted $\mu_I^J(p^e)$ in \emph{loc.\ cit.}, and equals $\nu_I^J(p^e)$ when $I$ is replaced with a polynomial, or is a principal ideal, but need not coincide in general.
For example, the two commands below give different output values.

{\small
\setstretch{.67}
\begin{MyVerbatim}

i1 : R = ZZ/3[x,y];

i2 : m = ideal(x, y);

o2 : Ideal of R

i3 : nu(3, m^5)

o3 = 10

i4 : nu(3, m^5, ContainmentTest => FrobeniusPower)

o4 = 8
\end{MyVerbatim}
}

\medspace
\noindent In line with the philosophy described in the introduction, after appropriately normalizing and taking the limit as $e$ approaches infinity, the values $\mu_I^J(p^e)$ determine certain invariants of interest called \emph{critical exponents}.

The last option we describe for {\tt nu} is {\tt IsLocal}.  When {\tt IsLocal => false} (the default is {\tt true}), then {\tt nu} ignores the option {\tt ContainmentTest} and the input ideal {\tt I}, and instead computes
\[
\min_{J \in \mathfrak{m}-\Spec R} (\nu_I^J(p^e))
\]
This is done by instead of computing for which $n$ we have $I^{n} \subseteq J^{[p^e]}$ (or equivalently, $(I^n)^{[1/p^e]} \subseteq J$), it computes for which $n$ we have $(I^n)^{[1/p^e]}$ is a unit ideal.


% R = ZZ/3[x,y];
% m = ideal(x, y);
% nu(3, m^5)
% nu(3, m^5, ContainmentTest => FrobeniusPower)





%%Below is the original version of the section describing the nu function

%\section{The $F$-pure threshold limit and {\tt nu}}
%\label{sec.Nu}
%
%Suppose $R = k[x_1, \dots, x_n]$ is a polynomial ring over a finite field and $f \in R$.    If $f^a \notin \langle x_1^{p^e}, \dots, x_n^{p^e} \rangle = \fram^{[p^e]}$, then the pair $(R, f^{a/(p^e -1)})$ is $F$-pure at the origin, whereas if $f^a \in \fram^{[p^e]}$, then the pair $(R, f^{a/p^e})$ is not $F$-pure at the origin.  By finding the $a \in \bZ$ where that transition happens, and then limiting over $e$, one can compute the $F$-pure threshold.  See \cite{MustataTakagiWatanabeFThresholdsAndBernsteinSato}.
%
%We set $\nu(e, f)$ to be largest $a \in \bZ$ such that $f^a \notin \fram^{[p^e]}$ (note in the literature, it is frequently denoted by $\nu_f(p^e)$.  It immediately follows that
%\[
%\fpt(f) = \lim_{e \to \infty} {\nu(e, f) \over p^e}.
%\]
%These numbers $\nu(e, f)$ can be computed using the command {\tt nu}, as in the example below.
%\medskip
%{\small
%\setstretch{.67}
%\begin{MyVerbatim}
%i1 : loadPackage "FThresholds"
%
%o1 = FThresholds
%
%o1 : Package
%
%i2 : R = ZZ/7[x,y]
%
%o2 = R
%
%o2 : PolynomialRing
%
%i3 : f = y^2 - x^3
%
%        3    2
%o3 = - x  + y
%
%o3 : R
%
%i4 : nu(1, f)
%
%o4 = 5
%
%o4 : QQ
%
%i5 : nu(2, f)
%
%o5 = 40
%
%o5 : QQ
%
%i6 : nu(3, f)
%
%o6 = 285
%
%o6 : QQ
%\end{MyVerbatim}
%}
%\medskip
%The numbers $5/7, 40/49, 285/343$ then approximate the $F$-pure threshold, which in this case happens to equal $5/6$.  By default, if the function $f$ has a special form (is a diagonal polynomial or a binomial), then the function does not check whether $f^a$ is in  $\langle x_1^{p^e}, \dots, x_n^{p^e} \rangle$, but instead uses general formulas for $\nu$s, see \cite{HernandezFPureThresholdOfBinomial,HernandezFInvariantsOfDiagonalHyp}.
%
%In fact, one can make the following more general definition.  If $I$ and $J$ are two ideals (with $I \subseteq \sqrt{J}$), one can define
%\[
%\nu(e, I, J) = \max \{ n \in \bZ \; |\; I^n \not\subseteq J^{[p^e]} \}.
%\]
%This is frequently denoted by $\nu_I^J(p^e)$ in the literature.  In the case that $I = \langle f \rangle$ and $J = \fram$, this just recovers the $\nu$'s defined above; the limit of which is the $F$-pure threshold.  For more general $I$ and $J$, the limit
%\[
%\lim_{e \to \infty} {\nu(e, I, J) \over p^e}
%\]
%is called the \emph{$F$-threshold of $I$ with respect to $J$}.  To compute these values we use a binary search, unless the user specifies that we should use a linear search instead {\tt Search=>Linear}.
%
%There is one more option that deserves mentioning, {\tt ContainmentTest}.  There are two ways to check whether $f^a$ (or $I^a$) is contained in $J^{[p^e]}$.  In general it is true that
%\[
%I^a \subseteq J^{[p^e]} \text{ $\Leftrightarrow$ } (I^a)^{[1/p^e]} \subseteq J
%\]
%where $\bullet^{[1/p^e]}$ is defined as in the {\tt TestIdeals} package.  Which of these two strategies to use is controlled by the option {\tt ContainmentTest => StandardPower} and {\tt ContainmentTest => FrobeniusRoot} respectively.
%For principal $I$, the command on the right is generally faster (and so {\tt FrobeniusRoot} is the default strategy for computing $\nu$).  For non-principal $I$, frequently the command on the left is quicker, and so {\tt StandardPower} is default strategy.
%
%Finally, the option {\tt ContainmentTest => FrobeniusPower}, then ${\tt \nu(e, I, A)}$ computes the largest integer $n$ such that
%\[
%I^{[p^n]} \subseteq J^{[p^e]}.
%\]
%See \cite{HernandezTeixeiraWittFrobeniusPowers} for more discussion of this.

\section{{\tt isFPT}, {\tt compareFPT} and {\tt isFJumpingExponent}}
\label{sec.IsFPT}

The \emph{FrobeniusThresholds} package contains methods to
 test candidate values for an $F$-pure threshold, and even $F$-jumping numbers, even in some singular rings.

Consider a  $\mathbb{Q}$-Gorenstein ring $R$ of characteristic $p>0$, whose index not divisible by $p$.
Given a parameter $t \in \mathbb{Q}$ and an element $f$ of $R$, the command {\tt isFPT(t,f)} outputs {\tt true} if $t$ is the $F$-pure threshold of $f$, and {\tt false} otherwise.
Moreover, the function {\tt compareFPT} provides further information about the relationship between $t$ and the $F$-pure threshold of $f$; namely,
{\tt compareFPT(t, f)} returns {\tt-1} , {\tt 0}, {\tt 1} when $t$ is less than, equal to, or greater than, respectively, the $F$-pure threshold of $f$.  Setting the option {\tt IsLocal} to {\tt true} tells the function to consider the $F$-pure threshold at the origin.  The following example illustrates this functionality.

{\small
\setstretch{.67}
\begin{MyVerbatim}

i1 : R = ZZ/11[x, y, z]/(x^2 - y*(z - 1));

i2 : compareFPT(5/11, z - 1)

o2 = -1

i3 : isFPT(1/2, z - 1)

o3 = true

i4 : isFPT(1/2, z - 1, IsLocal => true)

o4 = false
\end{MyVerbatim}
}
\medspace

The general method applied calls upon functionality from the \emph{TestIdeals} package \cite{TestIdealsPackage, TestIdealsPaper}.  The functions {\tt testIdeal} and {\tt FPureModule} therein are used
to compute the test ideals of $f$ with respect to the parameter $t$, and that with respect to $t - \varepsilon$, for $\varepsilon>0$ very small. For instance, as noted in the introduction, when $R$ is a polynomial ring, $t$ is the $F$-pure threshold of $f$ if and only if $\tau(R, f^t)$ is contained in the homogeneous maximal ideal, but
$\tau(R, f^{t-\varepsilon})$ is not.
(Note that for $R$ strongly $F$-regular and Gorenstein, {\tt FPureModule(t, f)} precisely computes $\tau(R, f^{t-\varepsilon})$.)
%These commands work more generally, but they \emph{only} currently work when $R$ is $\bQ$-Gorenstein, with index not divisible by $p$.

Since not only the $F$-pure thresholds, but also the higher $F$-jumping numbers, are determined by containment conditions on test ideals, the functionality is extended to determine whether a given number is an $F$-jumping number.
Analogous syntax is used, as shown in the following example.

{\small
\setstretch{.67}
\begin{MyVerbatim}

i49 : R = ZZ/13[x, y];

i50 : f = y*((y + 1) - (x - 1)^2)*(x - 2)*(x + y - 2);

i51 : isFJumpingExponent(3/4, f)

o51 = true
\end{MyVerbatim}
}
\medspace

\section{The {\tt fpt} function}
\label{sec.FPT}

The core function in the package \emph{FrobeniusThresholds} is called {\tt fpt}.  Throughout this section, let $f$ be a polynomial with coefficients in a finite field of characteristic $p$. When passed the polynomial $f$, the function {\tt fpt} attempts to find the exact value for the $F$-pure threshold of $f$ at the origin, and returns that value, if possible.  Otherwise, it returns lower and upper bounds for the $F$-pure threshold, as demonstrated below.

{\small
\setstretch{.67}
\begin{MyVerbatim}

i1 : ZZ/5[x,y,z];

i2 : fpt(x^3 + y^3 + z^3 + x*y*z)

     4
o2 = -
     5

o2 : QQ

i3 : fpt(x^5 + y^6 + z^7 + (x*y*z)^3)

      1  2
o3 = {-, -}
      3  5

o3 : List
\end{MyVerbatim}
}
\medspace

\subsection{The option {\tt UseSpecialAlgorithms} for the {\tt fpt} function}

The {\tt fpt} function has the option {\tt UseSpecialAlgorithms}.  When
set to {\tt true} (the default value), {\tt fpt} first checks whether $f$ is a monomial, a diagonal polynomial, a binomial, a form in two variables, or a product of factors in simple normal crossing, in that order.

If $f$ is a monomial, then its $F$-pure threshold is simply the minimum of the reciprocal of the exponent of each variable in $f$.
When $f$ is a diagonal polynomial, a binomial, or a form in two variables,
algorithms of Hern\'andez \cite{HernandezFInvariantsOfDiagonalHyp, HernandezFPureThresholdOfBinomial}, or Hern\'andez and Teixeira \cite{HernandezTeixeiraFThresholdFunctions},  are executed to compute the $F$-pure threshold.  Algorithms for computing $F$-pure thresholds of binomials also appear in \cite{ShibutaTakagiLCThresholds}, though they are only valid in certain special characteristics.

{\small
\setstretch{.67}
\begin{MyVerbatim}

i4 : fpt(x^3*y^4*z^5) -- a monomial

      1
o4 = -
      5

o4 : QQ


i5 : fpt(x^17 + y^20 + z^24) -- a diagonal polynomial

      94
o5 = ---
     625

i6 : fpt(x^2*y^6*z^10 + x^10*y^5*z^3) -- a binomial

      997
o6 = ----
     6250

o6 : QQ

i7 : ZZ/5[x,y];

i8 : fpt(x^2*y^6*(x + y)^9*(x + 3*y)^10) -- a form in two variables

      5787
o8 = -----
     78125

o8 : QQ
\end{MyVerbatim}
}
\medspace

The above noted algorithm for computing the $F$-pure threshold of a binary form $f$ requires factoring $f$ into linear forms, and {\tt fpt} can sometimes hang when attempting that factorization. For this reason, when a factorization is already known, the user can pass to {\tt fpt} a list containing all the pairwise prime linear factors of $f$, and a list containing their respective multiplicities.

{\small
\setstretch{.67}
\begin{MyVerbatim}

i9 : L = {x, y, x + y, x + 3*y};

i10 : m = {2, 6, 9, 10};

i11 : fpt(L, m) == o7

o11 = true
\end{MyVerbatim}
}
\medspace

If {\tt UseSpecialAlgorithms} is set to {\tt true} and $f$ does not fall into any of the four forementioned cases, then the function {\tt fpt} next calls {\tt isSimpleNormalCrossing(f)} to check whether the polynomial $f$ is a product of factors that are in simple normal crossing.  If this command returns {\tt true}, the $F$-pure threshold can easily be computed, and {\tt fpt} returns this value.  For more detail on the function {\tt isSimpleNormalCrossing} and on computing the $F$-pure threshold of a polynomial with simple normal crossings, please see Section \ref{subsec.SNC}.


\subsection{How {\tt fpt} proceeds when no special algorithm applies}

In the remainder of this section, we explain how the {\tt fpt} function proceeds when no special algorithm is available, or when {\tt UseSpecialAlgorithms} is set to {\tt false}, and describe the roles of the options {\tt DepthOfSearch} and {\tt Attempts}, whose values are both nonnegative integers.

In this case, the {\tt fpt} function either computes, and outputs, the exact value of the $F$-pure threshold of $f$, or otherwise recursively computes a finite sequence of lower and upper bounds for this value, and outputs the last of these, which will be the tightest among all computed.  The value of the option {\tt DepthOfSearch} determines the precision of the initial set of bounds, and the option {\tt Attempts}, in conjunction with some various subroutines, determines whether, and how, to produce new, tighter bounds from the previous ones.


More specifically, let $e$ denote the value of the option {\tt DepthOfSearch}, which conservatively defaults to {\tt 1}.  The {\tt fpt} function first computes $\nu=\nu_f(p^e)$, which agrees with the output of {\tt nu(e,f)}.  It is well known that the $F$-pure threshold of $f$ is greater than $\nu/p^e$ and at most $(\nu+1)/p^e$, and applying  \cite[Proposition 4.2]{HernandezFPurityOfHypersurfaces} to this lower bound tells us that the $F$-pure threshold of $f$ must be at least $\nu/(p^e-1)$.  In summary, we know that the $F$-pure threshold of $f$ must lie in the closed interval
%
\begin{equation}
\label{estimating-interval: e}
\tag{$\dagger$}
\left[ \frac{\nu}{p^e-1}, \frac{\nu+1}{p^e} \right].
\end{equation}

With these estimates in hand, the subroutine {\tt guessFPT} is called to make some ``educated guesses" in an attempt to identify the $F$-pure threshold within this interval, or at least narrow down this interval to produce improved estimates.  The number of ``guesses" is controlled by the option {\tt Attempts}, which conservatively defaults to {\tt 3}.  If {\tt Attempts} is set to {\tt 0}, then {\tt guessFPT} is bypassed. If  {\tt Attempts} is set to at least {\tt 1}, then a first check is run to verify whether the right-hand endpoint $(\nu+1)/p^e$ of the above interval \eqref{estimating-interval: e} is the $F$-pure threshold.  We illustrate this below.

{\small
\setstretch{.67}
\begin{MyVerbatim}

i11 : f = x^2*(x + y)^3*(x + 3*y^2)^5;

i12 : fpt(f, Attempts => 0) -- a bad estimate

          1
o12 = {0, -}
          5

o12 : List

i13 : fpt(f, Attempts => 0, DepthOfSearch => 3) -- a better estimate

        21   22
o13 = {---, ---}
       124  125

o13 : List

i14 : fpt(f, Attempts => 1, DepthOfSearch => 3) -- the right-hand

      endpoint (nu+1)/p^e is the F-pure threshold

       22
o14 = ---
      125

o14 : QQ

\end{MyVerbatim}
}

If  {\tt Attempts} is set to at least {\tt 2} and the right-hand endpoint $(\nu+1)/p^e$ of the interval \eqref{estimating-interval: e} is not the $F$-pure threshold, then a second check is run to verify whether the left-hand endpoint $\nu/(p^e-1)$ of this interval is the $F$-pure threshold.

{\small
\setstretch{.67}
\begin{MyVerbatim}

i15 : f = x^6*y^4 + x^4*y^9 + (x^2 + y^3)^3;

i16 : fpt(f, Attempts => 1, DepthOfSearch => 3)

       17   7
o16 = {--, --}
       62  25

o16 : List

i17 : fpt(f, Attempts => 2, DepthOfSearch => 3) -- the left-hand endpoint

      nu/(p^e-1) is the F-pure threshold

      17
o17 = --
      62

o17 : QQ

\end{MyVerbatim}
}

If neither endpoint is the $F$-pure threshold and {\tt Attempts} is set to more than {\tt 2}, then  additional checks are performed at certain numbers within the interval, chosen according to the criteria determined by the value of the option {\tt GuessStrategy}.  We refer the reader for the documentation of this strategy for more details.

{\color{red}  This will need to be updated.  Maybe look at Pedro's new documentation.}

{\small
\setstretch{.67}
\begin{MyVerbatim}

i18 : f = x^3*y^11*(x + y)^8*(x^2 + y^3)^8;

i19 : fpt(f, DepthOfSearch => 3, Attempts => 2)

        3   7
o19 = {--, ---}
       62  125

o19 : List

i20 : fpt(f, DepthOfSearch => 3, Attempts => 3) -- an additional check

      sharpens the estimate

        3   1
o20 = {--, --}
       62  18

o20 : List

i21 : fpt(f, DepthOfSearch => 3, Attempts => 4) -- and one more finds

      the answer

       1
o21 = --
      19

o21 : QQ
\end{MyVerbatim}
}
\medspace

If {\tt guessFPT} is unsuccessful and {\tt UseFSignature} is set to {\tt true}, then the {\tt fpt} function proceeds to use the convexity of the $F$-signature function and a secant line argument to attempt to narrow down the interval bounding the $F$-pure threshold.

{\small
\setstretch{.67}
\begin{MyVerbatim}

i22 : f = x^5*y^6*(x + y)^9*(x^2 + y^3)^4;

i23 : fpt(f, DepthOfSearch => 3)

        2   1
o23 = {--, --}
       31  14

o23 : List

i24 : fpt(f, DepthOfSearch => 3, UseFSignature => true)

        181   1
o24 = {----, --}
       2750  14

o24 : List

i25 : numeric o23

o25 = {.0645161, .0714286}

o25 : List

i26 : numeric o24 -- UseFSignature sharpened the estimate a bit

o26 = {.0658182, .0714286}

o26 : List
\end{MyVerbatim}
}
\medspace

When {\tt FRegularityCheck} is set to {\tt true} and no exact answer has been found, a final check is run to verify whether the final lower bound for the $F$-pure threshold is the exact answer (if it has not already been eliminated as a possibility).

{\small
\setstretch{.67}
\begin{MyVerbatim}

i27 : f = (x + y)^4*(x^2 + y^3)^6;

i28 : fpt( f, Attempts => 2, DepthOfSearch => 3 )

        3   13
o28 = {--, ---}
       31  125

o28 : List

i29 : fpt(f, Attempts => 2, DepthOfSearch => 3, UseFSignature => true)

      -- UseFSignature improves the answer a bit

        1   13
o29 = {--, ---}
       10  125

o29 : List

i30 : fpt(f, Attempts => 2, DepthOfSearch => 3, UseFSignature => true,

      FRegularityCheck => true) -- FRegularityCheck finds the answer

       1
o30 = --
      10

o30 : QQ
\end{MyVerbatim}
}
\medspace

The computations performed when {\tt UseFSignature} and {\tt FRegularityCheck} are set to {\tt true} are often slow, and often fail to improve the estimate, and for this reason, these options should be used sparingly.
            It is often more effective to increase the values of {\tt Attempts} or {\tt DepthOfSearch} instead.

{\small
\setstretch{.67}
\begin{MyVerbatim}

i31 : f = x^7*y^5*(x + y)^5*(x^2 + y^3)^4;

i32 : timing numeric fpt(f, DepthOfSearch => 3, UseFSignature => true,

      FRegularityCheck => true)

o32 = {.0733061, .0769231}
      -- 2.68899 seconds

o32 : Time

i33 : timing numeric fpt(f, Attempts => 5, DepthOfSearch => 3) -- a better

      answer in less time

o33 = {.075, .0769231}
      -- .893389 seconds

o33 : Time

i34 : timing fpt(f, DepthOfSearch => 4) -- the exact answer in even less
      time

       48
o34 = ---
      625
      -- .361882 seconds

o34 : Time
\end{MyVerbatim}
}
\medspace

As seen in several examples above, when the exact  $F$-pure threshold of $f$ is not found, a list containing the endpoints of an interval containing its value is returned.  Whether that interval is open, closed, or a mixed interval depends on the options passed; if the option {\tt Verbose} is set to {\tt true}, the precise interval will be printed.

{\small
\setstretch{.67}
\begin{MyVerbatim}

i35 : f = x^7*y^5*(x + y)^5*(x^2 + y^3)^4;

i36 : fpt(f, DepthOfSearch => 3, UseFSignature => true, Verbose => true)

Starting fpt ...

fpt is not 1 ...

Verifying if special algorithms apply...

Special fpt algorithms were not used ...

nu has been computed: nu = nu(3,f) = 9 ...

fpt lies in the interval [ nu/(p^e-1), (nu+1)/p^e ] = [ 9/124, 2/25 ] ...

Starting guessFPT ...

The right-hand endpoint is not the fpt ...

The left-hand endpoint is not the fpt ...

guessFPT narrowed the interval down to ( 9/124, 1/13 ) ...

Beginning F-signature computation ...

First F-signature computed: s(f,(nu-1)/p^e) = 456/15625 ...

Second F-signature computed: s(f,nu/p^e) = 64/15625 ...

Computed F-signature secant line intercept: 449/6125 ...

F-signature intercept is an improved lower bound ...

fpt failed to find the exact answer; try increasing the value of

DepthOfSearch or Attempts.

fpt lies in the interval [ 449/6125, 1/13 ).

        449   1
o36 = {----, --}
       6125  13

o36 : List
\end{MyVerbatim}
}
\medspace

\subsection{The function {\tt isSimpleNormalCrossings}} \label{subsec.SNC}
As mentioned earlier,
when the option {\tt useSpecialFunctions} for the function {\tt fpt} is set to {\tt true}, if the polynomial $f$ is neither a diagonal polynomial, a binomial, or a form in two variables, there is a final check to verify whether $f$ is a product of factors in simple normal crossing.

Suppose that $f$ has factorization $f_1^{a_i} f_2^{a_2} \cdots f_n^{a_n}$.  Recall that its factors $f_i$ are said to be in
\emph{simple normal crossing} at a point if, locally, they form part of a regular system of parameters.  The function {\tt isSimpleNormalCrossings} determines whether $f$ has simple normal crossings by computing the Jacobian matrix of each subset of $\{ f_i \}_{i=1}^n$ (evaluated at the origin), and checking that these matrices have the expected rank, and that these subsets generate ideals of the appropriate height.

{\small
\setstretch{.67}
\begin{MyVerbatim}

i1 : R = ZZ/7[x, y, z];

i2 : isSimpleNormalCrossing(x^3*y^2)

o2 = true

i3 : isSimpleNormalCrossing(x^2-y^2)

o3 = true

i4 : isSimpleNormalCrossing(x*y*(x-y))

o4 = false

i5 : isSimpleNormalCrossing(x^2-y*z)

o5 = false
\end{MyVerbatim}
}
\medspace

%             R = ZZ/7[x,y,z];
%             isSimpleNormalCrossing(x^3*y^2)
%             isSimpleNormalCrossing(x^2-y^2)
%             isSimpleNormalCrossing(x*y*(x-y))
%             isSimpleNormalCrossing(x^2-y*z)

If {\tt isSimpleNormalCrossing(f)} outputs true, then the $F$-pure threshold is easily computed, since is just the minimum of the values $1/a_i$, for $1 \leq i \leq n$.
Note that the function {\tt factor} is called whenever {\tt isSimpleNormalCrossing} is used, which can sometimes make the verification slow.  The user can avoid this when using {\tt fpt} by setting {\tt UseSpecialAlgorithms} to {\tt false}.

The function {\tt isSimpleNormalCrossing} is exposed to the user, so can be used independent of any $F$-pure threshold calculation.
If the user sets its option {\tt IsLocal} to {\tt true} (its default value is {\tt false}), then the function checks whether the $f_i$ are in simple normal crossing \emph{everywhere}, which can be much slower since Jacobian ideals are computed. Consider the following example illustrating this functionality.

{\small
\setstretch{.67}
\begin{MyVerbatim}

i1 : R = QQ[x, y, z];

i2 : f = (y - (x-1)^2)*y^2; --SNC at the origin, but not globally

i3 : isSimpleNormalCrossing(f)

o3 = true

i4 : isSimpleNormalCrossing(f, IsLocal=>false)

o4 = false

i5 : g = (y-1)^2+(x-7)^2 --doesn't even pass through the origin

       2    2
o5 = x  + y  - 14x - 2y + 50

o5 : R

i6 : isSimpleNormalCrossing(g)

o6 = true

i7 : isSimpleNormalCrossing(g, IsLocal=>false)

o7 = false

i8 : h = x*y^2*(x+1)^3*(y-1)^4; --SNC everywhere

i9 : isSimpleNormalCrossing(h)

o9 = true

i10 : isSimpleNormalCrossing(h, IsLocal=>false)

o10 = true
\end{MyVerbatim}
}
\medspace


%             R = QQ[x,y,z];

%             f = (y - (x-1)^2)*y^2; --SNC at the origin, but not globally

%             isSimpleNormalCrossing(f)

%             isSimpleNormalCrossing(f, IsLocal=>false)

%             g = (y-1)^2+(x-7)^2 --doesn't even pass through the origin

%             isSimpleNormalCrossing(g)

%             isSimpleNormalCrossing(g, IsLocal=>false)

%             h = x*y^2*(x+1)^3*(y-1)^4; --SNC everywhere

%             isSimpleNormalCrossing(h)

%             isSimpleNormalCrossing(h, IsLocal=>false)

\newpage
\section{Future Directions}
\label{sec.FutureDirections}

We conclude with some comments on possible improvements to the package.

One natural candidate for improvement would be to extend functionality to better handle nonprincipal ideals.  In particular, the package could be improved if it could use the test ideals $\tau(I^t)$ when $I$ is not necessarily principal.  Fortunately, the theoretical foundation for computing such ideals has already largely been worked out in the paper \cite{SchwedeTuckerTestIdealsOfNonPrincipal}. However, such an improvement would necessarily require an update to the \emph{TestIdeals} package.

\begin{enumerate}
\item Add more cases to {\tt UseSpecialAlgorithms}.
\item Add the capability to compute non-local {\tt fpt} and non-local {\tt nu} via an option.
\item Write a function that will extract from this sequences $\{ \nu_f^{\idealm}(p^e) \}_{e=1}^{\infty}$ roots of Bernstein-Sato polynomials.  Especially, strata.

\item Extend binary forms functions to handle more general $F$-thresholds (that is, with respect to diagonal ideals).  There is one tricky theoretical things, we don't know when this process would stop.  If we can do this, then we can compute $F$-pure thresholds of binary forms in non-standard gradings.  Cite the paper by Daniel and Pedro \cite{HernandezTeixeiraFThresholdFunctions}.
\end{enumerate}


\bibliographystyle{skalpha}
\bibliography{MainBib}



\end{document}
